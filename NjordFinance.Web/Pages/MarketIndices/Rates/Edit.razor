@page "/market-indices/rates/edit"

@inherits ModelPage<MarketIndexPrice>

@inject IBatchController<MarketIndexPrice> Controller
@inject IReferenceDataService ReferenceData

<PageTitle>@(PageTitle.ReadMany().AsPageTitle())</PageTitle>

    <ThemedComponent>
        <ModelPageMenuHeader ActionMenu="@ActionMenu" Header="@(PageTitle.ReadMany())" />

        <ContentTile>
            <Body>
                <SearchInputTable TModel="MarketIndexPrice"
                              ComparisonOperators=@ComparisonOperators
                              ExpressionBuilder=@ExpressionBuilder
                              SearchFields=@SearchFields
                              OnSearchClick=@(async (args) => await SearchClicked(args))>
                </SearchInputTable>
            </Body>
        </ContentTile>

        @if (IsLoading)
    {
        <LoadingSvg />
    }
    else
    {
        <ContentTile>
            <Body>
                @if (!string.IsNullOrEmpty(ErrorMessage))
                {
                    <div class="error-text">@ErrorMessage</div>
                }
                <EditForm width="100%" EditContext="@_context">
                    <ActionButtonMenu>
                        <button class="form-control button"
                            @onclick="@(async (args) => await Submit_OnClick(context, args))">
                            @Strings.Caption_Button_Save
                        </button>
                        <button class="form-control button"
                            @onclick="(async (args) => await AddNewAsync(args))">
                            @Strings.Caption_CreateNew.Format(ModelNoun?.GetSingular())
                        </button>
                        <button class="form-control button" @onclick="Cancel_OnClick"
                            @onclick:preventDefault>
                            @Strings.Caption_Button_Cancel
                        </button>
                    </ActionButtonMenu>
                    <DataAnnotationsValidator />
                    <DataGrid Data="@IndexPrices">
                        <DataGridColumn Property=@nameof(MarketIndexPrice.MarketIndexId)
                                    Caption=@(NameFor(x => x.MarketIndexId))>
                            <CellEditTemplate Context="model">
                                <InputSelect class="form-control"
                                    @bind-Value="@model.MarketIndexId">
                                    @foreach (var lookup in MarketIndexLookup)
                                    {
                                        <option value=@lookup.Key>@lookup.Display</option>
                                    }
                                </InputSelect>
                            </CellEditTemplate>
                        </DataGridColumn>
                        <DataGridColumn Property=@nameof(MarketIndexPrice.PriceCode)
                                    Caption=@(NameFor(x => x.PriceCode))>
                            <CellEditTemplate Context="model">
                                <InputSelect class="form-control"
                                    @bind-Value="@model.PriceCode">
                                    @foreach (var lookup in PriceCodeLookup)
                                    {
                                        <option value=@lookup.Key>@lookup.Display</option>
                                    }
                                </InputSelect>
                            </CellEditTemplate>
                        </DataGridColumn>
                        <DataGridColumn Property=@nameof(MarketIndexPrice.PriceDate)
                                    Caption=@(NameFor(x => x.PriceDate))>
                            <CellEditTemplate Context="model">
                                <InputDate class="form-control" @bind-Value="@model.PriceDate" />
                            </CellEditTemplate>
                        </DataGridColumn>
                        <DataGridColumn Property=@nameof(MarketIndexPrice.Price)
                                    Caption=@(NameFor(x => x.Price))>
                            <CellEditTemplate Context="model">
                                <InputNumber class="form-control" @bind-Value="@model.Price" />
                            </CellEditTemplate>
                        </DataGridColumn>
                    </DataGrid>
                </EditForm>
            </Body>
        </ContentTile>
    }
</ThemedComponent>

@code {
    private IList<MarketIndexPrice> IndexPrices { get; set; }

    private IEnumerable<LookupModel<string, string>> PriceCodeLookup { get; set; }

    private IEnumerable<LookupModel<int, string>> MarketIndexLookup {get; set;}

    private EditContext _context;

    private int MaxRecordCount { get; set; } = 100;

    private DateTime GetLastBusinessDay()
    {
        var currentDateTime = DateTime.UtcNow;

        DateTime lastBusinessDate = currentDateTime.DayOfWeek switch
        {
            DayOfWeek.Saturday => currentDateTime.Date.AddDays(-1),
            DayOfWeek.Sunday => currentDateTime.Date.AddDays(-2),
            _ => currentDateTime.Date
        };

        return lastBusinessDate;
    }
    private Expression<Func<MarketIndexPrice, bool>> InitialSearchExpression { get; set; }

    #region Search componenents
    /// <summary>
    /// Gets or sets the <see cref="IExpressionBuilder"/> for this component.
    /// </summary>
    [Inject]
    protected IExpressionBuilder ExpressionBuilder { get; set; } = default!;

    /// <summary>
    /// Gets or sets the collection of searchables fields for the type: <typeparamref name="TModel"/>.
    /// </summary>
    private IEnumerable<ISearchableMemberMetadata> SearchFields { get; set; }
        = Array.Empty<ISearchableMemberMetadata>();

    /// <summary>
    /// Gets or sets the collection of allowable <see cref="ComparisonOperator"/> for
    /// the type: <typeparamref name="TModel"/>.
    /// </summary>
    private IEnumerable<ComparisonOperator> ComparisonOperators { get; set; }
        = Array.Empty<ComparisonOperator>();

    #endregion

    /// <inheritdoc/>
    protected override async Task OnInitializedAsync()
    {
        IsLoading = true;

        ActionMenu = new()
            {
                IconKey = "reorder-four",
                Children = new()
                {
                    { 0, new MenuItem()
                        {
                            IconKey = "pencil",
                            Caption = string.Format(
                                Strings.Caption_EditMany, ModelNoun?.GetPlural()),
                            UriStem = $"{IndexUriRelativePath}/rates/edit"
                        }
                    }
                }
            };


        try
        {
            if (ExpressionBuilder is null)
                throw new ArgumentNullException(paramName: nameof(ExpressionBuilder));

            if (Controller is null)
                throw new ArgumentNullException(paramName: nameof(Controller));

            DateTime lastBusinessDay = GetLastBusinessDay();

            // InitialSearchExpression = x => x.PriceDate == lastBusinessDay;
            InitialSearchExpression = x => true;

            SearchFields = ExpressionBuilder!.GetSearchableMembers<MarketIndexPrice>();
            ComparisonOperators = ExpressionBuilder!.GetComparisonOperators();

            var queryActionResultTask = Controller!
                .SelectWhereAysnc(InitialSearchExpression, MaxRecordCount);

            await queryActionResultTask;

            using var queryBuilder = ReferenceData.CreateQueryBuilder<MarketIndex>();

            var indexLookupTask = queryBuilder.SelectDTOsAsync(
                    predicate: x => true,
                    maxCount: 0,
                    key: x => x.IndexId,
                    display: x => x.IndexCode,
                    defaultDisplay: Resources.Strings.Caption_InputSelect_Placeholder 
            );

            PriceCodeLookup = ReferenceData
                .SelectDTOsFromEnum<MarketIndexPriceCode, string, string>(
                    predicate: x => true,
                    key: x => x.ConvertToStringCode(),
                    display: x => NameFor<MarketIndexPriceCode>(x),
                    placeHolderDelegate: () => new LookupModel<string, string>()
                    {
                        Key = string.Empty,
                        Display = Resources.Strings.Caption_InputSelect_Placeholder
                    });


            var aggregateTask = Task.WhenAll(queryActionResultTask, indexLookupTask);
            await aggregateTask;

            IndexPrices = (await queryActionResultTask).Value;
            MarketIndexLookup = await indexLookupTask;
            _context = new(IndexPrices);
        }
        finally
        {
            IsLoading = IndexPrices is null
                || _context is null
                || MarketIndexLookup is null
                || PriceCodeLookup is null;
        }
    }

    /// <summary>
    /// Handles search submission events that that contain
    /// <see cref="SearchSubmittedEventArgs{TModel}"/> data.
    /// </summary>
    /// <param name="args">The <see cref="SearchSubmittedEventArgs{TModel}"/> that
    /// containst the data for the invoked event.</param>
    /// <returns>A task representing an asynchronous operator. Successful ooperation will
    /// cause <see cref="IndexPrices"/> to update to the collection matching the event arguments
    /// search expression.</returns>
    protected async Task SearchClicked(SearchSubmittedEventArgs<MarketIndexPrice> args)
    {
        try
        {
            IsLoading = true;
            if (args is not null)
            {
                var actionResult = await Controller!.SelectWhereAysnc(
                        predicate: args.SearchExpression, maxCount: MaxRecordCount);

                IndexPrices = actionResult.Value ?? new List<MarketIndexPrice>();
            }
        }
        finally
        {
            IsLoading = false;
        }
    }

    private async Task AddNewAsync(MouseEventArgs args)
    {
        // TODO: Do something with MouseEventArgs?

        var getDefaultTask = await Controller.GetDefaultAsync();
        await Controller.AddAsync(getDefaultTask.Value);

        if (getDefaultTask.Value is MarketIndexPrice model)
            IndexPrices.Insert(0, model);
    }

    private async Task DeleteAsync(MouseEventArgs args, MarketIndexPrice model)
    {
        var result = await Controller.DeleteOrDetachAsync(model);

        if (result is OkResult)
            IndexPrices.Remove(model);
        else
            throw new InvalidOperationException();

        // TODO: interpret the response.
    }

    private void Cancel_OnClick() => NavigationHelper.NavigateTo($"{IndexUriRelativePath}/rates");

    private async Task Submit_OnClick(EditContext context, MouseEventArgs args)
    {
        bool isValid = context.Validate();
        if (isValid)
        {
            var saveResult = await Controller.SaveChangesAsync();

            if (saveResult is NoContentResult)
                NavigationHelper.NavigateTo($"{IndexUriRelativePath}/rates");

            else if (saveResult is ObjectResult objectResult)
                ErrorMessage = (objectResult.Value as Exception)?.Message;
        }
    }
}
